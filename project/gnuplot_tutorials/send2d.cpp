

#define USE_CXX (__cplusplus >= 201103)

#include <vector>
#include <complex>
#include <cmath>

#include <boost/tuple/tuple.hpp>
#include <boost/array.hpp>
#include <boost/range/adaptor/transformed.hpp>
#include <boost/range/irange.hpp>
#include <boost/bind.hpp>
#include <boost/math/constants/constants.hpp>

#include <gnuplot-iostream/gnuplot-iostream.h>

#ifndef M_PI
#	define M_PI 3.14159265358979323846
#endif

#define PI boost::math::constants::pi<long double>()


void send3d() {
    Gnuplot gp(stdout);

    gp << "set xrange [0:10]\nset yrange [0:10]\nset zrange [0:10]\n";
    //gp << "set hidden3d nooffset\n";

    std::vector<boost::tuple<std::vector<double>,std::vector<double>,std::vector<double> > > pts;
    std::vector<double> x_pts(200);
    std::vector<double> y_pts(200);
    std::vector<double> z_pts(200);

    srand(time(NULL));
    for(int v=0; v<200; v++) {
        x_pts[v] = rand()%10;
        y_pts[v] = rand()%10;
        z_pts[v] = rand()%10;
    }
    pts.push_back(boost::make_tuple(x_pts, y_pts, z_pts));
    gp << "splot '-' with points title 'vec of boost::tuple of vec'\n";
    gp.send2d(pts);
    gp << std::endl;

}

void send3d_record() {

        Gnuplot gp;

        gp << "set xrange [0:10]\nset yrange [0:10]\nset zrange [0:10]\n";
        //gp << "set hidden3d nooffset\n";

        std::vector<boost::tuple<std::vector<double>,std::vector<double>,std::vector<double> > > pts;
        std::vector<double> x_pts(200);
        std::vector<double> y_pts(200);
        std::vector<double> z_pts(200);
        srand(time(NULL));
        for(int v=0; v<200; v++) {
            x_pts[v] = rand()%10;
            y_pts[v] = rand()%10;
            z_pts[v] = rand()%10;
        }
        pts.push_back(boost::make_tuple(x_pts, y_pts, z_pts));
        gp << "splot" << gp.binFile2d(pts, "record") << " with lines title 'vec of boost::tuple of vec'\n";
        gp << std::endl;

};

void send2d_colmajor() {
    //Gnuplot gp;
    // for debugging, prints to console
    Gnuplot gp;

    gp << "set zrange [0:1]\n";
    gp << "set hidden3d nooffset\n";

    // I use temporary files rather than stdin because the syntax ends up being easier when
    // plotting several datasets.  With the stdin method you have to give the full plot
    // command, then all the data.  But I would rather give the portion of the plot command for
    // the first dataset, then give the data, then the command for the second dataset, then the
    // data, etc.

    gp << "splot ";

    std::vector<std::tuple<std::vector<double>, std::vector<double>, std::vector<double> > >  pts;
    //std::vector<std::vector<std::vector<double> > > pts(3);

    std::vector<double> x_pts, y_pts, z_pts;


    for (int v = 0; v < 25; v++) {
        double z = 0;
        double x = std::cos(2.0 * M_PI * v / (24));
        double y = std::sin(2.0 * M_PI * v / (24));

        x_pts.push_back(x);
        y_pts.push_back(y);
        z_pts.push_back(z);
    }

    pts.push_back(std::make_tuple(x_pts, y_pts, z_pts));
    gp << gp.binFile2d(pts, "record") << "with lines title 'object1'";
    gp << std::endl;

}

void send_lemniscate() {

    Gnuplot gp;

    gp << "set zrange [1:12]\n";
    gp << "set hidden3d nooffset\n";

    // I use temporary files rather than stdin because the syntax ends up being easier when
    // plotting several datasets.  With the stdin method you have to give the full plot
    // command, then all the data.  But I would rather give the portion of the plot command for
    // the first dataset, then give the data, then the command for the second dataset, then the
    // data, etc.



    std::vector<std::tuple<std::vector<double>, std::vector<double>, std::vector<double> > > pts;
    std::vector<signed> theta;
    std::vector<double> x_pts, y_pts, z_pts, b_pts;
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(0, 360);

    const int runs = 5;
    int numRuns = 0;

    for (int n = 0; n < 100; n+=2) {
        //Use dis to transform the random unsigned int generated by gen into a double in [1, 2)
        theta.push_back(dis(gen)); //dis(gen)
        std::cout << theta[n] << ' '; //Each call to dis(gen) generates a new random double
    }

    while (numRuns++ < runs) {


        std::cout << '\n';

        std::string cx, cy, cz;
        // Lemniscate Noise Model
        for (int i = 0; i < 100; i++) {
            // Noise
            double x, y, z;
            x = 1 * cos(theta[i] * PI / 180.0) / (1.0 + std::pow(sin(theta[i] * PI / 180.0), 2));
            y = 1 * (cos(theta[i] * PI / 180.0) * sin(theta[i] * PI / 180.0)) / (0.2 + std::pow(sin(theta[i] * PI / 180.0), 2));

            x_pts.push_back(x);
            y_pts.push_back(y);
            z_pts.push_back((double) numRuns * 2); //(double) numRuns * 2

            if (i == numRuns) {
                cx = std::to_string(x);
                cy = std::to_string(y);
                cz = std::to_string(4);
            }

            // Real
        }

        //gp << "set label \"PT\" at " + cx + "," + cy + "," + cz + "; ";
        pts.push_back(std::make_tuple(x_pts, y_pts, z_pts));
        gp << "splot " << gp.binFile2d(pts, "record", "record.dat") << "with points title 'object1'";
        gp << std::endl;

        pts.clear();
        x_pts.clear();
        y_pts.clear();
        z_pts.clear();

        std::cout << "Sleep" << std::endl;
        usleep(500 * 1000);


    }


}

void test_liveplot(){

    Gnuplot gp;
    gp << "set zrange [-1:1]\n";

    const int N = 10;
    std::vector<std::vector<double>> points(N);


    for (int i = 0; i < N; i++) {
        std::vector<double> elem(3);
        elem[0] = i;
        elem[1] = i*i;
        elem[2] = 0;
        points.push_back(elem);
    }

    gp << "splot '-' binary" << gp.binFmt2d(points, "record") << "with points notitle\n";
    gp.sendBinary2d(points);
    gp.flush();

}

void demo_animation() {
#ifdef _WIN32
    // No animation demo for Windows.  The problem is that every time the plot
	// is updated, the gnuplot window grabs focus.  So you can't ever focus the
	// terminal window to press Ctrl-C.  The only way to quit is to right-click
	// the terminal window on the task bar and close it from there.  Other than
	// that, it seems to work.
	std::cout << "Sorry, the animation demo doesn't work in Windows." << std::endl;
	return;
#endif

    Gnuplot gp;

    std::cout << "Press Ctrl-C to quit (closing gnuplot window doesn't quit)." << std::endl;

    gp << "set yrange [-1:1]\n";

    const int N = 1000;
    std::vector<double> pts(N);

    double theta = 0;
    while(1) {
            for(int i=0; i<N; i++) {
                double alpha = (double(i)/N-0.5) * 10;
                pts[i] = sin(alpha*8.0 + theta) * exp(-alpha*alpha/2.0);
            }


        gp << "plot '-' binary" << gp.binFmt1d(pts, "array") << "with lines notitle\n";
        gp.sendBinary1d(pts);
        gp.flush();

        theta += 0.2;
        usleep(100000);
    }
}

int main() {

    //send3d();
    //send3d_record();
    //send2d_colmajor();
    send_lemniscate();
        //usleep(10000);

    //test_liveplot();
    //demo_animation();

    return 0;
}


